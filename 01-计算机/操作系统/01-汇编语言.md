# 0 写在前面

本笔记继续x86架构，Windows XP系统提供的实地址模式(16位系统)编写。

# 1 基础知识

## 1.1 机器语言&汇编

- duan机器指令是一列二进制数字，每一条机器指令都完整的描述了一个操作，机器语言是机器指令的集合

- 每一种微处理器，因设计的不同。从而导致机器指令的不同，因此机器语言是不能移植的

- 在同一种CPU结构下，每条机器语言指令都有对应的汇编指令，汇编语言更便于记忆

- 通过编译器，可以将汇编语言转换成机器语言

- 汇编语言的分类

  - 汇编指令：机器码助记符，由对应的机器码
  - 伪指令：由编译器执行，计算机不执行
  - 其他符号：如+、-、*、%。没有机器码，由编译器识别

  > 汇编指令是汇编语言的核心，它决定了汇编语言的特性

## 1.2 电脑硬件基础

电脑中的硬件大概有如下部分

- CPU
- 主板：利用总线连接电脑的各个部件
- 内存
- 各种接口卡
  - 显卡
  - 网卡
  - 声卡
  - 磁盘
- 电源

## 1.3 内存

- 指令和数据在内存中存放，在形式上二者没有任何区别，都是二进制信息
- 内存的最小存储单位称为**内存单元**，一个内存单元可以存储一个字节。内存的容量是以字节为最小单位来计算的
- 内存/磁盘容量的单位进制
  - 8bit = 1Byte
  - 1kb = 1024B
  - 1mb = 1024kb
  - 1gb = 1024mb
  - 1tb = 1024gb
- CPU从内存读写信息时，必须提供地址信息(内存地址)，控制信息(读/写)，数据信息(数据)。由这3中信息，可以将总线分为3类
  - 地址总线：一个CPU有N根地址线，则可以说这个CPU的地址总线宽度为N，最多可以寻找2^N个内存单元
  - 数据总线：一个CPU有N根数据线，则可以说这个CPU一次可以传输N位的数据
  - 控制总线：控制总线的宽度决定CPU对外部器件的控制能力
- 各种硬件：计算机系统中，所有可用程序控制其工作的设备，必须受到CPU的控制。
  - 主板：用来连接各个主要部件的底座
  - 接口卡：包括显卡，声卡等等。CPU通过总线向接口卡发送命令，接口卡根据命令控制外设的工作(CPU发送指令给显卡，显卡控制 显示器工作)
  - 各类存储器芯片：
    - RAM：随机存储器，存储器必须带电，关机后存储的内容丢失
    - ROM：只读存储器，关机后存储的内容不会丢失，但不能改变存储器中的内容（如BIOS）
    - 接口板RAM：有些接口卡需要大批量的数据输入，如显卡。会有一个接口板RAM来作为数据中继，如显存
- 内存地址空间：
  - 一个CPU有N根地址线，则可以说这个CPU的地址总线宽度为N，最多可以寻找2^N个内存单元。这2^N个内存单元被称为内存地址空间
  - CPU在操作内存地址空间时，会将主存，ROM，接口板RAM抽象为一个统一的线性逻辑存储器。该线性逻辑存储器的最大大小不超过内存地址空间(2^N)
  - 每个主存，接口板的内存都在线性逻辑存储器中占有一个地址段，称为一段地址空间。通过读写相应的地址段，就能控制相应的设备

# 2 寄存器

CPU的由如下器件组成

- 运算器：进行信息处理
- 寄存器：进行信息存储
- 控制器：控制各个部件之间的工作
- 内部总线：连接CPU内的各个部件

对于汇编程序员来讲，CPU中的主要部件是寄存器

## 2.1 通用寄存器

- 通用寄存器有AX，BX，CX，DX。每个寄存器可以存放2个字节

- 上述4个寄存器可以进行拆分，以AX举例：高8位为AH，低8位为AL。AH，AL每个寄存器有1个字节

- 字节：记为byte，一个字节由8bit组成，可以存放在8位寄存器中

- 字：记为word，一个字由两个字节组成，高8位组成高位字节，低8位组成低位字节

- 将4E20存放在AX中，其中 AH存放4E，AL存放4L

## 2.3 汇编指令01

```assembly
mov ax,18		;将18传递给AX寄存器
add ax,1406h	;等价于ax = ax+1406h
```

第二个操作数可以是直接数，也可以是寄存器。指令的两个对象的位数应当是一致的，即两个字数据作为操作数是合法的；一个字数据，一个字节数据的操作是非法的

## 2.4 x位结构CPU

例如16位结构(16位机，字长为16表达的都是一个意思)是指：

- 运算器一次最多可以处理16为数据
- 寄存器的最大宽度为16bit
- 寄存器和运算器之间的通路为16位

换句话说：在16位结构的cpu 内部，能够一次处理，传输，暂时存储的信息的最大长度为16bit

## 2.5 物理地址

在1.3中提到，操作系统会将所有内存单元抽象成一个线性地址空间。在这个线性地址空间中，每一个内存单元都有一个唯一的地址，这个唯一地址称为这个内存单元的物理地址
### 2.5.1 8086CPU给出物理地址的方法

8086CPU是16位结构的CPU。需要读写内存时，按照如下步骤进行：

1. CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址
2. 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件
3. 地址加法器将两个16位地址合成一个20位的物理地址
4. 地址加法器通过内部总线将20位物理地址送入输入输出控制电路
5. 输入输出控制电路将20位物理地址送上地址总线
6. 20位物理地址被地址总线传送到传输器

**物理地址计算公式**：物理地址 = 段地址 * 16 + 偏移地址

> 一个X进制的数据左移一位，就相当于乘X

### 2.5.2 段地址+偏移地址的本质含义

以8086CPU为例，如果只用16位地址总线，能表示的地址个数为：2^16 = 65536个

如果使用20位，能表示的地址个数为：2^20 =  1,048,576个

以希望有更大的内存位为大前提。我们盼望CPU内部可以处理20位的总线。但是，16位的CPU没法直接表示20位的地址

因此，如果提前定义一个公式：16位地址*常数+偏移地址，则可以在CPU内部总线较少的情况下，来得到更大的地址空间

所以，本质上：这种计算方式是用另一种方式来扩大内存地址空间

## 2.6 段的概念

- 内存没有真正意义上的分段，这里指的分段是通过程序员人为定义的。即一个地址可以用多个`段地址 * 16 + 偏移地址`来表示
- 这种分段的方式的主要目标是方便程序员来管理内存
- 在8086CPU中，一个段的起始地址一定是16的倍数，因为段地址*16
- 因为8086是16位结构的CPU，因此偏移地址最大为FFFF，一个段的最大长度为64KB

## 2.7 段寄存器

8086CPU中，段寄存器一共有4个：CS，DS，SS，ES

### 2.7.1 指令寄存器：CS和IP

CS为代码段寄存器，IP为指令指针寄存器

设CS的内容为M，IP中的内容为N。则8086CPU将从内存M*16+N单元开始，读取一条指令并执行

- 指令执行的顺序：
  1. 从CS：IP指向的内存单元读取指令 ，读取的指令进入指令缓冲器
  2. IP = IP + 所读取的指令的长度，从而指向下一条指令
  3. 执行指令。转到步骤1，重复执行
- 8086 CPU执行的第一条指令：在CPU加电或复位后，CS指向FFFFH，IP指向0000H。即FFFF0H单元中的指令是8086CPU开机执行的第一条指令
- CPU将CS：IP指向的内存单元中的内容看作指令
- 修改CS、IP的内容：
  - 同时修改CS、IP的内容：jmp 段地址:偏移地址
  - 仅修改IP： jmp 某一合法的寄存器(如ax,bx,cx...)

### 2.7.2 内存访问：DS 和 []

前面说过，用16位寄存器来存储一个字。高8位放高位字节，低8位存放低位字节

但如果使用内存存储一个字，这个字的低位字节存放在低地址单元中，高位字节存放在高地址字节中

**子单元**：存放一个字型数据的内存单元，由两个连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节

**N地址字单元**：将起始地址为N的字单元简称为N地址字单元

8086CPU中有一个DS寄存器，通常来存放要访问数据的段地址，偏移地址通过[]中的数据给出。其中[]中的内容可以是变量，也可以是寄存器

> 8086CPU 不允许将数据直接送入段寄存器，必须通过通用寄存器(ax,bx...)进行中转

### 2.7.3 栈 SS和SP

栈是一种具有特殊访问方式的存储空间。最后进入这个空间的数据，最先出去

每一个栈都应该有一个标记，标记栈顶元素的位置。任意时刻，SS：SP指向栈顶 元素

栈有两种操作：入栈，出栈

- 入栈：PUSH ax
  1. SP = SP - 2，SS：SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶
  2. 将ax中的内容送入SS：SP指向的内存单元处，SS：SP此时指向新的栈顶
- 出栈：POP ax
  1. 将SS：SP指向的内存单元处的元素送入ax中
  2. SP = SP+2，SS：SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶

> 8086CPU中，低地址单元为栈顶方向；高地址单元为栈底方向
>
> push，pop指令后面可以为通用寄存器，段寄存器，内存(可以在内存单元与内存单元间直接传送数据)

**注意：**8086CPU只知道栈顶在哪里，不知道整个栈的大小及栈段的位置。因此8086CPU无法管控栈溢出问题

# 3 补充一些信息

## 3.1 完整的汇编程序

### 3.1.1 汇编程序生命周期

1. 编写汇编程序：使用编辑器编写汇编程序
2. 对源程序进行编译连接：用汇编器先对程序进行编译，再使用连接器对程序进行连接
3. 执行可执行文件中的程序

### 3.1.2 指令的分类及汇编程序的结构

- 汇编指令：有机器码对应的汇编指令，最终被编译为机器指令被CPU执行
- 伪指令：没有对应的机器指令，有编译器理解。CPU不执行

汇编程序的结构

```assembly
assume cs:abc

abc segment

	mov ax,2
	add ax,ax
	add ax,ax
	
	;程序返回
	mov ax,4c00h
	int 21H

abc ends

end
```

伪代码标记：

- 程序段：程序段开始用segment标记，程序段结束用ends标记。一个汇编程序由多个程序段组成，可以将代码，数据，栈分段存储
- end：程序结束标志，编译器遇到end，结束编译
- assume：假设有一寄存器和程序中的某个程序段相关联
- 标号：上述程序中，abc属于标号的范畴。标号指代了一个地址

DOS中文件执行过程：在DOS中，可执行文件A要运行，必须有一个正在运行的B，将A从可执行文件中加载入内存，将CPU的控制权交给A，A得以运行，A运行完毕后，应该将CPU的控制权交还给它得以运行的程序B

> 源程序与程序
>
> - 源程序是指程序员编写的汇编程序
> - 程序是指源程序中最终由计算机执行、处理的指令或数据

## 3.2 其他事项

- 程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为ds:0
- 这个内存区的前256个字节存放的是PSP，DOS用来和程序进行通信。从256字节处向后的空间存放的是程序。因此，程序的物理地址为：(SA（PSP段地址）+ 16)*16 + 0，即SA+10H：0
- 要完整的描述一个内存单元，需要两种信息：
  1. 内存单元的地址
  2. 内存单元的长度
- 描述性符号:`()`；该符号不能出现在任何代码中 ，只是作为流程描述中。表示一个内存单元或一个寄存器中的内容
- 描述性常量`idata`：该符号不能出现在任何代码中 ，只是作为流程描述中。表示一个常量
- [寄存器]：将寄存器中的值作为DS寄存器的偏移地址。请注意，在源代码中，不能出现`mov ax,[1]`这种指令，这种指令等价于`mov ax,1` 应该使用`mov ax,ds:[1]`
- 在汇编源程序中，数据不能以字母开头，如`A000H`，应该为`0A000H`
- 段前缀：出现在访问内存单元的指令中，用于显示地指明内存单元的段地址的寄存器标号(如`ds`,`cs`等等)，在汇编语言称为段前缀
- 一段安全的内存空间：
  - 我们需要直接向一段内存中写入内容
  - 待写入的内存空间不应存放操作系统或其他程序的数据或代码，否则写入操作很可能引发错误
  - DOS方式下，一般情况，0：200~0：2ff空间中没有系统或其他程序的数据或代码
  - CPU实模式下，可以直接操控硬件，不理会上述的安全机制。在保护模式下，必须遵守上述的安全机制

# 4 循环吧，代码

loop指令是汇编中的循环指令，CPU执行loop指令时，要进行两步操作

1. (cx) = (cx) - 1

2. 判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行

   ```assembly
   ; s为循环的标号，cx不为0时，从这里开始执行
   s:	mov ax,bx
   	loop s
   ```

注意事项：

1. 在cx中存放循环次数
2. loop指令中的标号所标识地址要在前面
3. 要循环执行的程序段，要写在标号和loop指令的中间

# 5 包含多个段的程序

在操作系统中，合法地通过操作系统取得的空间都是安全的，因为操作系统不会让一个程序所用的空间和其他程序以及系统 自己的空间相冲突。在操作系统允许的情况下，程序可以取得任意容量的空间

程序获取所需空间的方法有如下两种：

1. 在加载程序的时候为程序分配(本笔记只记录该中方法)：通过在源程序中定义段来进行内存空间的截取
2. 程序在执行的过程中向系统申请

我们定义不同的段来存储代码，栈，程序数据

## 5.1 定义数据

```assembly
; 使用dw定义一个字长的数据
dw 0123h,0234h

; 使用db定义一个字节的数据
db 00h,12h

; 使用dd定义两个字长的数据
dd 12345678h,00000000h,1a234567h
```

> 定义数据的同时也开辟了内存空间，如C语言中生命变量一样

## 5.2 程序开始标记

```assembly
assume cs:code,ds:data,ss:stack

data segment
data ends

stack segment
stack ends

code segment
; 使用start标记程序开始
start:
code ends
end start	; 使用start标记程序开始
```

- end除了结束程序结束的地点外，还可以告诉编译器程序的入口在哪里
- start只是标号而已，也可以不用start。使用start可以更清晰的表明标号含义
- 程序入口，即开始地址存放在可执行文件 中的描述信息中
- 在3.2中 说过：ds:0指向的是程序的PSP空间首地址，CS：0指向的是程序的首地址。程序的第一条指令需要结合开始标记重新计算IP，最后CS:IP是程序的第一条指令所在的内存地址

## 5.3 将程序的不同部分，分成不同的段

```assembly
assume cs:code,ds:data,ss:stack

data segment
data ends

stack segment
stack ends

code segment
start:
code ends
end start	
```

- 分段使用segment ... ends关键字，定义多个段使用不同的段名即可，如data,stack,code。需要注意的是：assume只代表假设，不代表code段真的和cs寄存器关联
- 每个段的段名，如data，stack；代表这个段的地址。这个段地址是一个常量，不能直接将这个地址送进段寄存器
- 代码段的标号只是方便程序员理解段的内容，不是硬性指定。如data段可以叫做info段

# 6 逻辑命令，字符，数组，结构体

## 6.1 逻辑命令

- 逻辑与：and

  ```assembly
  mov al,01100011B
  and al,00111011B	;与操作
  ; 结果：00100011B
  ```

  该指令可将操作对象的相应位设为0，其他位不变

- 逻辑或：or

  ```assembly
  mov al,01100011B
  or  al,00111011B
  ;结果： 01111011B
  ```

  该指令可将操作对象的相应位设为1，其他位不变

## 6.2 字符

本笔记的字符集使用ASCII码

编码解码过程(文本编辑器领域)：在记事本中按下a键，这个按键的信息被送入计算机，计算机用ASCII码的规则将其转变为61H并存储在指定的内存空间中；记事本从内存取出61H，将其送到显卡上的显存中；工作在文本模式下的显卡，用ASCII码的规则解释显存中的内容，61H被当作字符a，显卡驱动显示器，将字符a的图像花在屏幕上

### 6.2.1 以字符形式给出的数据

```assembly
assume cs:code,ds:data

data segment
	db 'unIX'
data ends

code segment
start: 	mov al,'a'

		mov ax,4c00h
        int 21h
code ends

end start
```

- 汇编中的字符及字符串放在`''`中，每个字母占一字节(ASCII规定)
- `ab 'unIX'`相当于`db 75H,6EH,49H,58H`
- `mov al,'a'`相当于 `mov al,61H`

可见，操作字符相当于操作整数，操作N个字符的字符串相当于操作N个 整数

### 6.2.2 大小写转换

一个神奇的大小写转换方式(字符需要采用ASCII编码)：

A的ASCII码是`01000001`，a的ASCII码是`01100001`。可以看出，只有第5位不一致；第5位为0，表示大写，第五位为1，表示小写

```assembly
; 小写转大写:第5位变为1，其他不变
or al,00100000B
; 大写转小写：第5位变为0，其他不变
and al,11011111B
```

## 6.3 数组

###  6.3.1 一维数组 [bx+idata]

使用汇编语言定义一些字符数组数组

```assembly
datasg segment
	db 'BaSiC'
	db 'MiniX'
datasg ends
```

使用[bx+idata]访问两个字符串中的第一个元素

```assembly
mov bx,datasg
mov ds,bx
; 移动B到al
mov al,[bx]
; 移动M到al
mov al,5[bx]
```

### 6.3.2 二维数组，结构体 [bx+si],[bx+di]

有如下数据定义：

```assembly
; 每个字符串的长度为一个字
datasg segment
	db 'ibm        '
	db 'dec        '
	db 'vax        '
datasg ends
```

访问时，使用[bx+si]的方式。si,di是两个通用寄存器，类似于bx。但是si,di不支持拆分。即没有bl，bh这样的8位寄存器

```assembly
mov ax,datasg
mov ds,ax
; 访问ibm
mov bx,0
mov si,0
mov al,[bx+si]
; 访问dec
add bx,16
mov al,[bx+si]
```

### 6.3.3 表格数据 [bx+si+idata]

公司信息的结构如下所示

```
名称(字符串)：DEC
总裁姓名(字符串)：Ken Olsen
排名(数字)：137
收入(数字)：40
著名产品(字符串)：PDP
```

假设在内存中起始位置使用reg:60记录，相对于seg:60，各个变量的偏移如下

```
00 'DEC'	; 即 reg:60
03 'Ken Oslen'	; 即 reg:63
0C 137
0E 40
10 'PDP'
```

访问著名产品使用如下方式

```assembly
mov ax,reg
mov ds,reg
mov bx,60
mov si,0

mov al,[bx].10h[si]	; bx表示公司内容所在的位置，10h表示著名产品所在的单元格，si表示产品的第一个字母
```

# 7 补充一些信息及总结

可以参加内存单元寻址的寄存器：bx，si，di，bp。这4个寄存器可以单个出现，也可以以下面的组合出现

- bx和si
- bx和di
- bp和si
- bp和di

如果在[...]中使用寄存器bp，而指令中没有显性给出段地址，段地址默认在ss中

计算机处理数据的时候需要的信息：

- 处理的数据在什么地方
- 要处理的数据有多长

一个指令中必须直接或间接提供如上两条信息，否则计算机就无法工作

## 7.1 机器指令处理的数据在什么地方

机器指令大概分为如下3类：

- 读取
- 写入
- 运算

机器指令不关心数据的值是什么，关心指令执行的前一刻，数据所在的位置

- CPU内部
- 内存
- 端口

根据数据所在的位置，机器指令可用如下方式表达数据的位置

1. 立即数：数据直接包含在汇编指令中

   ```assembly
   mov ax,1 ; 1就是立即数
   ```

2. 寄存器：数据在寄存器中

   ```assembly
   mov ax,bx ; ax,bx就是立即数
   ```

3. 段地址和偏移地址：数据在内存中

   ```assembly
   mov ax,[bx+si]	;[]中的内容为偏移地址，段地址在寄存器ds/ss中
   ```

数据存放在内存中时，可以用多种方式来给定这个内存单元的偏移地址，这种定位内存的方式一般被称为寻址方式

1. 直接寻址

   ```assembly
   mov ax,[idata]
   ```

2. 寄存器间接寻址-

   ```assembly
   mov ax,[bx]
   ```

3. 寄存器相对寻址：通常用于数组

   ```assembly
   mov ax,[bx+idata]
   ```

4. 基址变址寻址：通常用于二位数组

   ```assembly
   mov ax,[bx+si]
   ```

5. 相对基址变址寻址：用于表格结构的数组

   ```assembly
   mov ax,[bp+di+idata]
   ```

## 7.2  数据的长度

1. 通过寄存器名指明要处理的数据的长度

   ```assembly
   mov ax,1	; 由于ax是字长度处理器，所有这条指令为一个字长
   ```

2. 用操作符X ptr指明内存的长度

   ```assembly
   mov word ptr ds:[0],1	; 使用word ptr指明将1存放在字长的内存中
   ```

3. 其他方式：如push指令只进行字操作

## 7.3 补充一些指令

- div：除法指令

  - 除数：有8位和16位两种，在一个reg或内存单元中
  - 被除数：默认放在AX或DX和AX中
    - 如果除数为8位，被除数则为16位，默认在AX中存放；
    - 如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位
  - 结果
    - 如果除数为8位，则AL存储除法操作的商，AH存放除法操作的余数
    - 如果除数为16位，则AX存储除法操作的商，DX存放除法操作的余数

  > 除法操作，只要除数/被除数超过寄存器指定位数。则跳转至16位除法

- dd：定义双字数据

  ```assembly
  data segment
  	dd 1	; 定义一个双字(4字节)长度的变量
  data ends
  ```

- dup：用来进行数据的重复(主要节省时间)

  ```assembly
  stack segment
  	db 200 dup (0)	; 分配200个一字节内存空间，每个内存空间的内容都为0
  stack ends
  ```

  



